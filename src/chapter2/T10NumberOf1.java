package chapter2;

/**
 * 其实二进制的位运算并不是很难掌握，因为位运算总共只有五种运算：与、或、异或、左移或右移。左移运算符m<<n表示把m左移n位。
 * 左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。右移运算符m>>n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。
 * 但右移时处理最左边位的情况要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位。也就是说如果数字原先是一个正数，
 * 则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1.
 * 面试题10“二进制中1的个数”就是直接考查位运算的例子，而面试题40“数组中只出现一次的数字”、面试题47“不用加减乘除做加法”等
 * 都是根据位运算的特点来解决问题。
 *
 * 面试题10：二进制中1的个数
 * 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。
 *
 * 测试用例：
 * 正数（包括边界值1/0x7FFFFFFF）。
 * 负数（包括边界值0x80000000/0xFFFFFFFF）。
 * 0
 *
 * 相关题目：
 * 1. 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位是0。
 * 根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。
 *
 * 2. 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010，12的二进制表示为1101，需要改变
 * 1010中的3位才能得到1101。 我们可以分为两步解决这个问题：第一步求这两个数的异或，第二步统计异或结果中1的位数。
 *
 * 举一反三：
 * 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0.很多二进制问题都可以用这个思路解决。
 *
 * Created by 郑元浩 on 2017/8/9.
 */
public class T10NumberOf1 {

    /**
     * 思路：先判断整数二进制表示中最右边一位是不是1.接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断是不是1。
     * 这样每次移动一位，直到整个整数变成为0为止。现在的问题变成怎么判断一个整数的最右边是不是1了。这很简单，只要把整数和1做位与运算看结果是不是0就知道了。
     * 1除了最右边的一位之外所有位都是0.如果一个整数与1做与运算的结果是1，表示该整数最右边一位是1，否则是0。
     *
     * 问题1：把整数右移一位和把整数除以2在数学上是等价的，那上面的代码中可以把右移运算换成除以2吗？答案是否定的。因为除法的效率比移位运算要低得多，
     * 在实际编程中应尽可能地用移位运算符代替乘除法。
     *
     * 问题2：上面的函数如果输入一个负数，比如0x80000000，运行的时候会发生什么情况？把负数0x80000000右移一位时，并不是简单地把最高位的1移到第二位变成
     * 0x40000000，而是0xC0000000。这是因为移位前是个负数，仍然要保证移位后是个负数，因此移位后的最高位会设为1.如果一直做右移运算，最终这个数字就会变成
     * 0xFFFFFFFF而陷入死循环。
     *
     * 思路2：常规解法是
     * 为了避免死循环，我们可以不右移输入的数字i。首先把i和1做与运算，判断i的最低位是不是为1。接着把1左移移位得到2，再和i做与运算，就能判断i的次低位是不是1。。。
     * 这样反复左移，每次就能判断i的其中一位是不是1。
     *
     * @param n
     * @return
     */
    public static int numberOfOne(int n){
        // 记录数字中1的个数
        int result = 0;

        // Java语言规范中，int整形占4个字节，总计32位
        // 对每一个位置与1进行求与操作，再累加就可以求出当前数字的表示是多少位1
        for (int i = 0; i < 32; i++) {
            result += (n & 1);
            n >>>= 1;
        }

        // 返回求得的结果
        return result;
    }

    /**
     * 在分析这种算法之前，我们先来分析把一个数减去1的情况。如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1。先假设这个数的最右边一位是1，
     * 那么减去1时，最后一位变成0而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由1变成了0。
     * 接下来假设最后一位不是1而是0的情况。如果该整数的二进制表示中最右边1位于第m位，那么减去1时，第m位由1变成0，而第m位之后的所有0变成1，整数中
     * 第m位之前的所有位都保持不变。举个例子：一个二进制数1100，它的第二位是从最右边数起的一个1.减去1后，第二位变成0，它后面的两位0变成1，而前面的
     * 1保持不变，因此得到的结果是1011。
     * 在前面的两种情况中，我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1，而它左边所有位都保持不变。接下来我们把
     * 一个整数和它减去1的结果做位运算，相当于把它最右边的1变成0。还是以前面的1100为例，它减去1的结果是1011。我们再把1100和1011做位与运算，得到的结果
     * 是1000。我们把1100最右边的1变成了0，结果刚好是1000。
     *
     * 总结：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。
     *
     * @param n
     * @return
     */
    public static int numberOfOne2(int n){
        // 记录数字中1的位数
        int result = 0;

        // 数字的二进制表示中有多少个1就进行多少次操作
        while (n != 0) {
            result++;
            // 从最右边的1开始，每一次操作都使n得最右的一个1变成0
            n = (n - 1) & n;
        }

        // 返回求得结果
        return result;
    }

    public static void main(String[] args){
        System.out.println(numberOfOne(0B00000000_00000000_00000000_00000000)); // 0
        System.out.println(numberOfOne(0B00000000_00000000_00000000_00000001)); // 1
        System.out.println(numberOfOne(0B11111111_11111111_11111111_11111111)); // -1
//        System.out.println(0B01111111_11111111_11111111_11111111 == Integer.MAX_VALUE);
        System.out.println(numberOfOne(0B01111111_11111111_11111111_11111111)); // Integer.MAX_VALUE
//        System.out.println(0B10000000_00000000_00000000_00000000 == Integer.MIN_VALUE);
        System.out.println(numberOfOne(0B10000000_00000000_00000000_00000000)); // Integer.MIN_VALUE

        System.out.println("");
        System.out.println(numberOfOne2(0B00000000_00000000_00000000_00000000)); // 0
        System.out.println(numberOfOne2(0B00000000_00000000_00000000_00000001)); // 1
        System.out.println(numberOfOne2(0B11111111_11111111_11111111_11111111)); // -1
        System.out.println(numberOfOne2(0B01111111_11111111_11111111_11111111)); // Integer.MAX_VALUE
        System.out.println(numberOfOne2(0B10000000_00000000_00000000_00000000)); // Integer.MIN_VALUE
    }

}
